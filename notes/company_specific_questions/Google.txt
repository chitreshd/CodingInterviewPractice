1. Clone Graph [M]
-----------------
Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.


OJ's undirected graph serialization:
Nodes are labeled uniquely.

We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.
As an example, consider the serialized graph {0,1,2#1,2#2,2}.

The graph has a total of three nodes, and therefore contains three parts as separated by #.

First node is labeled as 0. Connect node 0 to both nodes 1 and 2.
Second node is labeled as 1. Connect node 1 to node 2.
Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.
Visually, the graph looks like the following:

       1
      / \
     /   \
    0 --- 2
         / \
         \_/

Ans: Use BFS/DFS to traverse the graph. At each visit, clone the node(i.e. create a clone object and mark all its
neighbors) and its neighbors. Add cloned neighbors to cloned node.
Careful: Multiple clone of one node shouldn't be created.
Mistakes:
a. Assumed by simply traversing DFS / BFS clone will be created. Initially, ignored the importance of keeping
unique clones for each node.
b. For visited DS, I used set and a separate map for maintaining unique relationships between label and map. The
optimization was to use map to maintain relationship and also as a visited DS.

2. Binary Tree Paths [E]
---------------------
Given a binary tree, return all root-to-leaf paths.

For example, given the following binary tree:

   1
 /   \
2     3
 \
  5
All root-to-leaf paths are:

["1->2->5", "1->3"]

Ans: Pre-order tree traversal. Keep passing ancestors to children. At each level check for leaf. If leaf, then print.
Careful: Maintenance of ancestral links.

3. Find Median from Data Stream [H]
--------------------------------
Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.

Examples:
[2,3,4] , the median is 3

[2,3], the median is (2 + 3) / 2 = 2.5

Design a data structure that supports the following two operations:

void addNum(int num) - Add a integer number from the data stream to the data structure.
double findMedian() - Return the median of all elements so far.
For example:

addNum(1)
addNum(2)
findMedian() -> 1.5
addNum(3)
findMedian() -> 2

Ans: Maintain 2 heaps: Left heap which is max heap and right heap which is min. Also always left > right by one or
left == right. The median is:
if left > right: median = left.head ( max of left side: ex: 1,2,3,4,5. left = 1,2,3, median = 3)
if left == right: median = left.head + right.head / 2. (ex: 1,2,3,4; left = 1,2, right=3,4 left.max = 2,
right.min = 3, median = 2 + 3 / 2)

4. Implement Trie [M]
---------------------
Implement a trie with insert, search, and startsWith methods.

Note:
You may assume that all inputs are consist of lowercase letters a-z.

Ans: For strings: [ abc, ac, bac, ace ] , create a tree like following:
                # ( root node empty )
             /      \
          a             b
        /  \            |
      b     c(w)        a
      |     |           |
      c(w)  e(w)        c(w)

      