1. Longest Substring Without Repeating Characters [M]
------------------------------------------------------
Given a string, find the length of the longest substring without repeating characters.

Examples:

Given "abcabcbb", the answer is "abc", which the length is 3.
Given "bbbbb", the answer is "b", with the length of 1.
Given "pwwkew", the answer is "wke", with the length of 3. Note that the answer must be a substring, "pwke" is a subsequence and not a substring.

Answer: sliding window. keep pushing end and adding chars to "seen" hash set. whenever
a new char in s is found in "seen", we found duplicate. So keep sliding start pointer
to right until char c is no longer in "seen". As we slide start, keep removing the
startIndex char from "seen".

Mistakes: FLAWLESS VICTORY

2. Longest Palindromic Substring [M]
------------------------------------------------------
Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

Example:
Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.
Example:
Input: "cbbd"
Output: "bb"

Answer: for each index as a center get the max palindrome for that index. compare this max with global max. end of
iteration we should have a max palindrome.

mistakes:
- incorrectly guessed the brute force complexity
- above mistake prevented me from getting to a optimal solution as I thought that the sub-optimal solution also have same time complexity

Note: the brute force is O(n^3), Explanation: Brute force solution is to get all possible palindromes. We get this by
starting from biggest window, sliding it and during every slide, checking if the substring is palindrome or not.
Thus (# of windows) * (# of slides per window ) * (# check for palindrom ) nearly = O(n^3)

3. Copy List with Random Pointer
------------------------------------------------------
A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.
Return a deep copy of the list.

Answer: In first pass create a deep copy of linked list while maintaining map of label:cloneNode. In this pass, dont
worry about random pointer. In second pass, use the map to retreive the cloneNode for random.label in orig list
and assign it to the cloneNode.

Mistakes: FLAWLESS VICTORY

4. Word Ladder II [H]
---------------------
Given two words (beginWord and endWord), and a dictionary's word list, <u>find all</u> shortest transformation sequence
(s) from beginWord to endWord, such that:

 Only one letter can be changed at a time
 Each transformed word must exist in the word list. Note that beginWord is not a transformed word.
 For example,

 Given:
 beginWord = "hit"
 endWord = "cog"
 wordList = ["hot","dot","dog","lot","log","cog"]
 Return
 [
 ["hit","hot","dot","dog","cog"],
 ["hit","hot","lot","log","cog"]
 ]
 Note:
 Return an empty list if there is no such transformation sequence.
 All words have the same length.
 All words contain only lowercase alphabetic characters.
 You may assume no duplicates in the word list.
 You may assume beginWord and endWord are non-empty and are not the same.

 Solution:
 Create paths by using character iteration
 Use BFS to traverse these paths
 Maintain a map of word: List of "from". ( this helps in generating all lists through
 backtracking)
 In BFS, its important to check if a node is visited before adding it to the "queue"
 (Its different from DFS where we check visit condition after popping item from stack )

 Mistakes:
 Timeout error: One optimization I didn't consider is using Dijisktra's search.
 Although nobody would ask me to code, but it would be worth mentioning.
 https://discuss.leetcode.com/topic/2857/share-two-similar-java-solution-that-accpted-by-oj

